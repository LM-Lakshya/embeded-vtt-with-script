<html>
<head>
  <meta charset="utf-8">
  <title>MP4Box.js in the browser</title>
  <script src="https://github.com/gpac/mp4box.js/releases/download/v0.3.15/mp4box.all.js"></script>
  <!-- <script src="https://gpac.github.io/mp4box.js/dist/mp4box.all.js"></script> -->
  <!-- <script type="https://github.com/gpac/mp4box.js/blob/a8f4cd883b8221bedef1da8c6d5979c2ab9632a8/test/downloader.js"></script>
  <script src="http://download.tsi.telecom-paristech.fr/gpac/mp4box.js/downloader.js"></script>
 -->
 	<!-- <script type="downloader.js"></script> -->
</head>
<body>

<div style="position: relative; width: 50%; height: 50%">
  <!-- poster="http://gpac.wp.mines-telecom.fr/files/2014/01/FondBig_1600x230.png" -->
  <video id="v" width="600" height="400" autoplay controls poster="https://peach.blender.org/wp-content/uploads/title_anouncement.jpg"> </video>
  <div id="overlayTracks" style="position: absolute; top: 0px; width: 100%; height: 95%;"></div>
</div>

<script type="text/javascript">

// http://download.tsi.telecom-paristech.fr/gpac/mp4box.js/index.js

var MYURL="mp4box-vtt-out.mp4"
var chunkSize = 1000000;
var chunkTimeout = 500;
var segmentSize = 1000;
var extractionSize = 1;
var saveChecked=true;

/* Setting the level of logs (error, warning, info, debug) */
Log.setLogLevel(Log.info);

/* The main object processing the mp4 files */
var mp4box;
/* Metadata extracted from the mp4 file */
var movieInfo;

/* the HTML5 video element */
var video;
var overlayTracks;

var autoplay = false;

/* object responsible for file downloading */
var downloader = new Downloader();
downloader.setDownloadTimeoutCallback = setDownloadTimeout;

function Downloader() {
	this.isActive = false;
	this.realtime = false;
	this.chunkStart = 0;
	this.chunkSize = 0;
	this.totalLength = 0;
	this.chunkTimeout = 1000;
	this.url = null;
	this.callback = null;
	this.eof = false;
	this.setDownloadTimeoutCallback = null;
}

Downloader.prototype.setDownloadTimeoutCallback = function(callback) {
	this.setDownloadTimeoutCallback = callback;
	return this;
}

Downloader.prototype.reset = function() {
	this.chunkStart = 0;
	this.totalLength = 0;
	this.eof = false;
	return this;
}

Downloader.prototype.setRealTime = function(_realtime) {
	this.realtime = _realtime;
	return this;
}

Downloader.prototype.setChunkSize = function(_size) {
	this.chunkSize = _size;
	return this;
}

Downloader.prototype.setChunkStart = function(_start) {
	this.chunkStart = _start;
	this.eof = false;
	return this;
}

Downloader.prototype.setInterval = function(_timeout) {
	this.chunkTimeout = _timeout;
	return this;
}

Downloader.prototype.setUrl = function(_url) {
	this.url = _url;
	return this;
}

Downloader.prototype.setCallback = function(_callback) {
	this.callback = _callback;
	return this;
}

Downloader.prototype.isStopped = function () {
	return !this.isActive;
}

Downloader.prototype.getFileLength = function () {
	return this.totalLength;
}

Downloader.prototype.getFile = function() {
	var dl = this;
	if (dl.totalLength && this.chunkStart>= dl.totalLength) {
		dl.eof = true;
	}
	if (dl.eof === true) {
		Log.info("Downloader", "File download done.");
		this.callback(null, true);
		return;
	}
	var xhr = new XMLHttpRequest();
	xhr.open("GET", this.url, true);
	xhr.responseType = "arraybuffer";
	var range = null;
	xhr.start = this.chunkStart;
	var maxRange;
	if (this.chunkStart+this.chunkSize < Infinity) {
		range = 'bytes=' + this.chunkStart + '-';
		maxRange = this.chunkStart+this.chunkSize-1;
		/* if the file length is known we limit the max range to that length */
		/*if (dl.totalLength !== 0) {
			maxRange = Math.min(maxRange, dl.totalLength);
		}*/
		range += maxRange;
		xhr.setRequestHeader('Range', range);
	}
	xhr.onerror = function(e) {
		dl.callback(null, false, true);
	}
	xhr.onreadystatechange = function (e) { 
		if (xhr.status == 404) {
			dl.callback(null, false, true);
		}	
		if ((xhr.status == 200 || xhr.status == 206 || xhr.status == 304 || xhr.status == 416) && xhr.readyState == this.DONE) {
			var rangeReceived = xhr.getResponseHeader("Content-Range");
			Log.info("Downloader", "Received data range: "+rangeReceived);
			/* if the length of the file is not known, we get it from the response header */
			if (!dl.totalLength && rangeReceived) {
				var sizeIndex;
				sizeIndex = rangeReceived.indexOf("/");
				if (sizeIndex > -1) {
					dl.totalLength = +rangeReceived.slice(sizeIndex+1);
				}
			}
			dl.eof = (xhr.response.byteLength !== dl.chunkSize) || (xhr.response.byteLength === dl.totalLength);
			var buffer = xhr.response;
			buffer.fileStart = xhr.start;
			if (!buffer.fileStart) {
				// IE does not support adding properties to an ArrayBuffer generated by XHR
				buffer = buffer.slice(0);
				buffer.fileStart = xhr.start;
			}
			dl.callback(buffer, dl.eof); 
			if (dl.isActive === true && dl.eof === false) {
				var timeoutDuration = 0;
				if (!dl.realtime) {
					timeoutDuration = dl.chunkTimeout;
				} else {
					timeoutDuration = computeWaitingTimeFromBuffer(video);
				}
				if (dl.setDownloadTimeoutCallback) dl.setDownloadTimeoutCallback(timeoutDuration);
				Log.info("Downloader", "Next download scheduled in "+Math.floor(timeoutDuration)+ ' ms.');
				dl.timeoutID = window.setTimeout(dl.getFile.bind(dl), timeoutDuration);
			} else {
				/* end of file */
				dl.isActive = false;
			}
		}
	};
	if (dl.isActive) {
		Log.info("Downloader", "Fetching "+this.url+(range ? (" with range: "+range): ""));
		xhr.send();
	}
}

Downloader.prototype.start = function() {
	Log.info("Downloader", "Starting file download");
	this.chunkStart = 0;
	this.resume();
	return this;
}

Downloader.prototype.resume = function() {
	Log.info("Downloader", "Resuming file download");
	this.isActive = true;
	if (this.chunkSize === 0) {
		this.chunkSize = Infinity;
	}
	this.getFile();
	return this;
}

Downloader.prototype.stop = function() {
	Log.info("Downloader", "Stopping file download");
	this.isActive = false;
	if (this.timeoutID) {
		window.clearTimeout(this.timeoutID);
		delete this.timeoutID;
	}
	return this;
}


/* main functions, MSE-related */
function resetMediaSource() {
	var mediaSource;
	mediaSource = new MediaSource();
	mediaSource.video = video;
	video.ms = mediaSource;
	mediaSource.addEventListener("sourceopen", onSourceOpen);
	mediaSource.addEventListener("sourceclose", onSourceClose);
	video.src = window.URL.createObjectURL(mediaSource);
  console.log("resetMediaSource video.src", video.src);
	/* TODO: cannot remove Text tracks! Turning them off for now*/
	for (var i = 0; i < video.textTracks.length; i++) {
		var tt = video.textTracks[i];
		tt.mode = "disabled";
	}
}

function load() {
	var ms = video.ms;
  console.log("load ms.readyState", ms.readyState);
	if (ms.readyState !== "open") {
		return;
	}

	mp4box = new MP4Box(); // old
	//mp4box = MP4Box.createFile(); // new

  console.log("mp4box", mp4box);
  console.log("mp4box", mp4box);
	mp4box.onMoovStart = function () {
		Log.info("Application", "Starting to parse movie information");
	}
	mp4box.onReady = function (info) {
		Log.info("Application", "Movie information received");
		movieInfo = info;
		if (info.isFragmented) {
			ms.duration = info.fragment_duration/info.timescale;
		} else {
			ms.duration = info.duration/info.timescale;
		}
		//displayMovieInfo(info, infoDiv);
    console.log("displayMovieInfo", info);
		addSourceBufferListener(info);
		stop();
		if (autoplay) {
			initializeAllSourceBuffers();
		} else {
			initAllButton.disabled = false;
		}
	}
	mp4box.onItem = function(item) {
		var metaHandler = mp4box.inputIsoFile.getMetaHandler();
		if (metaHandler.startsWith("mif1")) {
			var pitem = mp4box.inputIsoFile.getPrimaryItem();
			console.log("Found primary item in MP4 of type "+item.content_type);
			if (pitem.id === item.id) {
				video.poster = window.URL.createObjectURL(new Blob([item.data.buffer]));
			}
		}
	}
	mp4box.onSegment = function (id, user, buffer, sampleNum) {
		var sb = user;
		saveBuffer(buffer, 'track-'+id+'-segment-'+sb.segmentIndex+'.m4s');
		sb.segmentIndex++;
		sb.pendingAppends.push({ id: id, buffer: buffer, sampleNum: sampleNum });
		Log.info("Application","Received new segment for track "+id+" up to sample #"+sampleNum+", segments pending append: "+sb.pendingAppends.length);
		onUpdateEnd.call(sb, true, false);
	}
	mp4box.onSamples = function (id, user, samples) {
		var sampleParser;
		var cue;
		var texttrack = user;
		Log.info("TextTrack #"+id,"Received "+samples.length+" new sample(s)");
		for (var j = 0; j < samples.length; j++) {
			var sample = samples[j];
			if (sample.description.type === "wvtt") {
				sampleParser = new VTTin4Parser();
				cues = sampleParser.parseSample(sample.data);
				for (var i = 0; i < cues.length; i++) {
					var cueIn4 = cues[i];
					cue = new VTTCue(sample.dts/sample.timescale, (sample.dts+sample.duration)/sample.timescale, (cueIn4.payl ? cueIn4.payl.text : ""));
					texttrack.addCue(cue);
				}
			} else if (sample.description.type === "metx" || sample.description.type === "stpp") {
				sampleParser = new XMLSubtitlein4Parser();
				var xmlSubSample = sampleParser.parseSample(sample);
				console.log("Parsed XML sample at time "+Log.getDurationString(sample.dts,sample.timescale)+" :", xmlSubSample.document);
				cue = new VTTCue(sample.dts/sample.timescale, (sample.dts+sample.duration)/sample.timescale, xmlSubSample.documentString);
				texttrack.addCue(cue);
				cue.is_sync = sample.is_sync;
				cue.onenter = processInbandCue;
			} else if (sample.description.type === "mett" || sample.description.type === "sbtt" || sample.description.type === "stxt") {
				sampleParser = new Textin4Parser();
				if (sample.description.txtC && j===0) {
					if (sample.description.txtC.config) {
					} else {
						sample.description.txtC.config = sampleParser.parseConfig(sample.description.txtC.data);
					}
					console.log("Parser Configuration: ", sample.description.txtC.config);
					texttrack.config = sample.description.txtC.config;
				}
				var textSample = sampleParser.parseSample(sample);
				console.log("Parsed text sample at time "+Log.getDurationString(sample.dts,sample.timescale)+" :", textSample);
				cue = new VTTCue(sample.dts/sample.timescale, (sample.dts+sample.duration)/sample.timescale, textSample);
				texttrack.addCue(cue);
				cue.is_sync = sample.is_sync;
				cue.onenter = processInbandCue;
			}
		}
	}

	//loadButton.disabled = true;
	//startButton.disabled = true;
	//stopButton.disabled = false;

	downloader.setCallback(
		function (response, end, error) {
			var nextStart = 0;
			if (response) {
				//progressbar.progressbar({ value: Math.ceil(100*downloader.chunkStart/downloader.totalLength) });
        console.log("progressbar", Math.ceil(100*downloader.chunkStart/downloader.totalLength));
				nextStart = mp4box.appendBuffer(response);
			}
			if (end) {
				//progressbar.progressbar({ value: 100 });
        console.log("progressbar", 100);
				mp4box.flush();
			} else {
				downloader.setChunkStart(nextStart);
			}
			if (error) {
				reset();
				//progresslabel.text("Download error!");
        console.log("progressbar", "Download error!");
			}
		}
	);
	downloader.setInterval(chunkTimeout);
	downloader.setChunkSize(chunkSize);
	downloader.setUrl(MYURL);
	//loadButton.disabled = true;
	downloader.start();
}

function setDownloadTimeout(value) {
	var b;
	// chunkTimeoutLabel.value = value;
	// chunkTimeoutInput.value = value;
	// downloader.setInterval(parseInt(value));
	downloader.setInterval(500);
	b = Math.floor(1000000*8/500);
	//chunkDownloadBitRate.innerHTML = b;
  console.log("setDownloadTimeout", b);
}

function onSeeking(e) {
	var i, start, end;
	var seek_info;
	if (video.lastSeekTime !== video.currentTime) {
		for (i = 0; i < video.buffered.length; i++) {
			start = video.buffered.start(i);
			end = video.buffered.end(i);
			if (video.currentTime >= start && video.currentTime <= end) {
				return;
			}
		}
		/* Chrome fires twice the seeking event with the same value */
		Log.info("Application", "Seeking called to video time "+Log.getDurationString(video.currentTime));
		downloader.stop();
		resetCues();
		seek_info = mp4box.seek(video.currentTime, true);
		downloader.setChunkStart(seek_info.offset);
		downloader.resume();
		//startButton.disabled = true;
		//stopButton.disabled = false;
		video.lastSeekTime = video.currentTime;
	}
}


function onSourceClose(e) {
	var ms = e.target;
	if (ms.video.error) {
		Log.error("MSE", "Source closed, video error: "+ ms.video.error.code);
	} else {
		Log.info("MSE", "Source closed, no error");
	}
}

function onSourceOpen(e) {
	var ms = e.target;
	Log.info("MSE", "Source opened");
	Log.debug("MSE", ms);
	//urlSelector.disabled = false;
  play(); // this call instantiates mp4box, via load()
}

function addSourceBufferListener(info) {
	for (var i = 0; i < info.tracks.length; i++) {
		var track = info.tracks[i];
		console.log("addSourceBufferListener addTrack", i, track.id);
		// if (!checkBox) continue;
		// checkBox.addEventListener("change", (function (t) {
		// 	return function (e) {
		// 		var check = e.target;
		// 		if (check.checked) {
		// 			addBuffer(video, t);
		// 			initButton.disabled = false;
		// 			initAllButton.disabled = true;
		// 		} else {
		// 			initButton.disabled = removeBuffer(video, t.id);
		// 			initAllButton.disabled = initButton.disabled;
		// 		}
		// 	};
		// })(track));
	}
}


function initializeAllSourceBuffers() {
	if (movieInfo) {
		var info = movieInfo;
		for (var i = 0; i < info.tracks.length; i++) {
			var track = info.tracks[i];
			addBuffer(video, track);
			//var checkBox = document.getElementById("addTrack"+track.id);
			//checkBox.checked = true;
		}
		initializeSourceBuffers();
	}
}

function initializeSourceBuffers() {
	var initSegs = mp4box.initializeSegmentation();
	for (var i = 0; i < initSegs.length; i++) {
		var sb = initSegs[i].user;
		if (i === 0) {
			sb.ms.pendingInits = 0;
		}
		sb.addEventListener("updateend", onInitAppended);
		Log.info("MSE - SourceBuffer #"+sb.id,"Appending initialization data");
		sb.appendBuffer(initSegs[i].buffer);
		saveBuffer(initSegs[i].buffer, 'track-'+initSegs[i].id+'-init.mp4');
		sb.segmentIndex = 0;
		sb.ms.pendingInits++;
	}
	//initAllButton.disabled = true;
	//initButton.disabled = true;
}


function onInitAppended(e) {
	var sb = e.target;
	if (sb.ms.readyState === "open") {
		updateBufferedString(sb, "Init segment append ended");
		sb.sampleNum = 0;
		sb.removeEventListener('updateend', onInitAppended);
		sb.addEventListener('updateend', onUpdateEnd.bind(sb, true, true));
		/* In case there are already pending buffers we call onUpdateEnd to start appending them*/
		onUpdateEnd.call(sb, false, true);
		sb.ms.pendingInits--;
		if (autoplay && sb.ms.pendingInits === 0) {
			start();
		}
	}
}

function onUpdateEnd(isNotInit, isEndOfAppend) {
	if (isEndOfAppend === true) {
		if (isNotInit === true) {
			updateBufferedString(this, "Update ended");
		}
		if (this.sampleNum) {
      //var trak = mp4box.getTrackById(this.id); // new
      //if (typeof trak.samples !== 'undefined') {
      //  mp4box.releaseUsedSamples(this.id, this.sampleNum);
      //}
      var trak = mp4box.inputIsoFile.getTrackById(this.id);
      console.log("onUpdateEnd", this.id, this.sampleNum, trak, trak.samples); // mp4box.getTrackById(this.id)); // mp4box.releaseSample()
      if (typeof trak.samples !== 'undefined') {
        mp4box.releaseUsedSamples(this.id, this.sampleNum);
      }
      delete this.sampleNum;
		}
	}
	if (this.ms.readyState === "open" && this.updating === false && this.pendingAppends.length > 0) {
		var obj = this.pendingAppends.shift();
		Log.info("MSE - SourceBuffer #"+this.id, "Appending new buffer, pending: "+this.pendingAppends.length);
		this.sampleNum = obj.sampleNum;
		this.appendBuffer(obj.buffer);
	}
}

function updateBufferedString(sb, string) {
	var rangeString;
	if (sb.ms.readyState === "open") {
		rangeString = Log.printRanges(sb.buffered);
		Log.info("MSE - SourceBuffer #"+sb.id, string+", updating: "+sb.updating+", currentTime: "+Log.getDurationString(video.currentTime, 1)+", buffered: "+rangeString+", pending: "+sb.pendingAppends.length);
		//if (sb.bufferTd === undefined) {
		//	sb.bufferTd = document.getElementById("buffer"+sb.id);
		//}
		//sb.bufferTd.textContent = rangeString;
    Log.info("updateBufferedString sb.bufferTd",rangeString);
	}
}


function addBuffer(video, mp4track) {
	var sb;
	var ms = video.ms;
	var track_id = mp4track.id;
	var codec = mp4track.codec;
	var mime = 'video/mp4; codecs=\"'+codec+'\"';
	var kind = mp4track.kind;
	var trackDefault;
	var trackDefaultSupport = (typeof TrackDefault !== "undefined");
	var html5TrackKind = "";
	if (codec == "wvtt") {
		if (!kind.schemeURI.startsWith("urn:gpac:")) {
			html5TrackKind = "subtitles";
		} else {
			html5TrackKind = "metadata";
		}
	} else {
		if (kind && kind.schemeURI === "urn:w3c:html5:kind") {
			html5TrackKind = kind.value || "";
		}
	}
	if (trackDefaultSupport) {
		if (mp4track.type === "video" || mp4track.type === "audio") {
			trackDefault = new TrackDefault(mp4track.type, mp4track.language, mp4track.name, [ html5TrackKind ], track_id);
		} else {
			trackDefault = new TrackDefault("text", mp4track.language, mp4track.name, [ html5TrackKind ], track_id);
		}
	}
	if (MediaSource.isTypeSupported(mime)) {
		try {
			Log.info("MSE - SourceBuffer #"+track_id,"Creation with type '"+mime+"'");
			sb = ms.addSourceBuffer(mime);
			if (trackDefaultSupport) {
				sb.trackDefaults = new TrackDefaultList([trackDefault]);
			}
			sb.addEventListener("error", function(e) {
				Log.error("MSE SourceBuffer #"+track_id,e);
			});
			sb.ms = ms;
			sb.id = track_id;
			mp4box.setSegmentOptions(track_id, sb, { nbSamples: segmentSize } );
			sb.pendingAppends = [];
		} catch (e) {
			Log.error("MSE - SourceBuffer #"+track_id,"Cannot create buffer with type '"+mime+"'" + e);
		}
	} else {
		Log.warn("MSE", "MIME type '"+mime+"' not supported for creation of a SourceBuffer for track id "+track_id);
		var i;
		var foundTextTrack = false;
		for (i = 0; i < video.textTracks.length; i++) {
			var track = video.textTracks[i];
			if (track.label === 'track_'+track_id) {
				track.mode = "showing";
				track.div.style.display = 'inline';
				foundTextTrack = true;
				break;
			}
		}
		if (!foundTextTrack) {
			var texttrack = video.addTextTrack(html5TrackKind, mp4track.name, mp4track.language);
			texttrack.id = track_id;
			texttrack.mode = "showing";
			mp4box.setExtractionOptions(track_id, texttrack, { nbSamples: extractionSize });
			texttrack.codec = codec;
			texttrack.mime = codec.substring(codec.indexOf('.')+1);
			texttrack.mp4kind = mp4track.kind;
			texttrack.track_id = track_id;
			var div = document.createElement("div");
			div.id = "overlay_track_"+track_id;
			div.setAttribute("class", "overlay");
			overlayTracks.appendChild(div);
			texttrack.div = div;
			initTrackViewer(texttrack);
		}
	}
}

function initTrackViewer(track) {
	if (track.mime === "image/x3d+xml" && typeof(x3dom) === "undefined") {
		var link = document.createElement("link");
		link.type = "text/css";
		link.rel = "stylesheet";
		link.href= "trackviewers/x3d/x3dom.css";
		document.head.appendChild(link);
		var s = document.createElement("script");
		s.async = true;
		s.type="application/ecmascript";
		s.src = "trackviewers/x3d/x3dom.js";
		document.head.appendChild(s);
	} else if (track.mp4kind.schemeURI === "urn:gpac:kinds" && track.mp4kind.value === "gps") {
		track.oncuechange = setupGpsTrackPositionViewer(track, track.div);
	} else if (track.mp4kind.schemeURI === "urn:gpac:kinds" && track.mp4kind.value === "beats") {
		track.oncuechange = setupMusicBeatTrackViewer(track, track.div);
	} else if (track.mp4kind.schemeURI === "urn:gpac:kinds" && track.mp4kind.value === "lyrics") {
		track.oncuechange = setupFancySubtitleTrackViewer(track, track.div);
	}
}

function saveBuffer(buffer, name) {
	//if (saveChecked.checked) {
	if (saveChecked) {
		var d = new DataStream(buffer);
		d.save(name);
	}
}


/* main player functions */
function reset() {
	stop();
	downloader.reset();
	//startButton.disabled = true;
	resetMediaSource();
	//resetDisplay();
}


function start() {
	//startButton.disabled = true;
	//stopButton.disabled = false;
  console.log("start() running");
	downloader.setChunkStart(mp4box.seek(0, true).offset);
	downloader.setChunkSize(chunkSize);
	downloader.setInterval(chunkTimeout);
	mp4box.start();
	downloader.resume();
}

function stop() {
	if (!downloader.isStopped()) {
		//stopButton.disabled = true;
		//startButton.disabled = false;
		downloader.stop();
	}
}

function play() {
	//playButton.disabled = true;
	autoplay = true;
	video.play();
	load();
}


window.onload = function () {
	video = document.getElementById('v');
	overlayTracks = document.getElementById('overlayTracks');

	video.addEventListener("seeking", onSeeking);
	video.addEventListener("error", function (e) {
		Log.error("Media Element error", e);
	});
	video.playing = false;
	video.addEventListener("playing", function(e) {
		console.log("Playing event,");
		video.playing = true;
		if (video.onPlayCue) {
			processInbandCue.call(video.onPlayCue);
			video.onPlayCue = null;
		}
	});

  reset(); // enough to trigger "[MSE] Source opened"; resetMediaSource video.src blob:null/5716acf8-abe2-40b3-9ec3-4d0722614070
  //play(); // calls load(), where MYURL is set; but load() will exit before "[MSE] Source opened"; so here it's useless
  //start(); // here: TypeError: mp4box is undefined

  // after succesful startup, getting:
  //[0:00:00.297] [MSE] MIME type 'video/mp4; codecs="tx3g"' not supported for creation of a SourceBuffer for track id 3 mp4box.all.js:33:5
  //TypeError: Argument 1 of HTMLMediaElement.addTextTrack '' is not a valid value for enumeration TextTrackKind. test.html:332:20
  // only WebVTT/VTT/WVTT subtitles supported
}


</script>

</body>
</html>